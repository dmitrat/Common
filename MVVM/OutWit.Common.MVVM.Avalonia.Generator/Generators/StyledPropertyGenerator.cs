using Microsoft.CodeAnalysis;
using System.Linq;
using System.Text;

namespace OutWit.Common.MVVM.Avalonia.Generator.Generators
{
    internal sealed class StyledPropertyGenerator
    {
        #region Fields

        private readonly IPropertySymbol m_propertySymbol;
        private readonly INamedTypeSymbol m_containingType;
        private readonly AttributeData m_attributeData;
        private readonly bool m_isAttached;
        private readonly bool m_isDirect;

        #endregion

        #region Constructors

        public StyledPropertyGenerator(
            IPropertySymbol propertySymbol,
            INamedTypeSymbol containingType,
            AttributeData attributeData,
            bool isAttached,
            bool isDirect)
        {
            m_propertySymbol = propertySymbol;
            m_containingType = containingType;
            m_attributeData = attributeData;
            m_isAttached = isAttached;
            m_isDirect = isDirect;
        }

        #endregion

        #region Functions

        public string Generate()
        {
            var namespaceName = m_containingType.ContainingNamespace?.ToDisplayString();
            var className = m_containingType.Name;
            var propertyName = m_propertySymbol.Name;
            var propertyType = m_propertySymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            var dpPropertyName = GetAttributeValue<string>("PropertyName") ?? $"{propertyName}Property";
            var defaultValue = GetAttributeValue<object>("DefaultValue");
            var bindsTwoWayByDefault = GetAttributeValue<bool>("BindsTwoWayByDefault");
            var inherits = GetAttributeValue<bool>("Inherits");

            // Convention-based callback discovery
            var onChanged = GetAttributeValue<string>("OnChanged") ?? FindCallbackMethod($"On{propertyName}Changed");
            var coerce = GetAttributeValue<string>("Coerce") ?? FindCoerceMethod($"{propertyName}Coerce");

            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();

            if (!string.IsNullOrEmpty(namespaceName))
            {
                sb.AppendLine($"namespace {namespaceName}");
                sb.AppendLine("{");
            }

            var indent = string.IsNullOrEmpty(namespaceName) ? "" : "    ";

            sb.AppendLine($"{indent}partial class {className}");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    #region Styled Properties");
            sb.AppendLine();

            if (m_isDirect)
            {
                GenerateDirectProperty(sb, indent, dpPropertyName, propertyName, propertyType,
                    defaultValue, bindsTwoWayByDefault, onChanged);
            }
            else if (m_isAttached)
            {
                GenerateAttachedProperty(sb, indent, dpPropertyName, propertyName, propertyType,
                    defaultValue, inherits, onChanged, coerce);
            }
            else
            {
                GenerateStyledPropertyField(sb, indent, dpPropertyName, propertyName, propertyType,
                    defaultValue, inherits, bindsTwoWayByDefault, onChanged, coerce);
            }

            sb.AppendLine($"{indent}    #endregion");
            sb.AppendLine($"{indent}}}");

            if (!string.IsNullOrEmpty(namespaceName))
            {
                sb.AppendLine("}");
            }

            return sb.ToString();
        }

        private string? FindCallbackMethod(string conventionName)
        {
            var method = m_containingType.GetMembers(conventionName)
                .OfType<IMethodSymbol>()
                .FirstOrDefault(m => IsPropertyChangedCallback(m));

            return method?.Name;
        }

        private string? FindCoerceMethod(string conventionName)
        {
            var method = m_containingType.GetMembers(conventionName)
                .OfType<IMethodSymbol>()
                .FirstOrDefault(m => IsCoerceCallback(m));

            return method?.Name;
        }

        private bool IsPropertyChangedCallback(IMethodSymbol method)
        {
            // Avalonia callback signature: void OnPropertyChanged(AvaloniaPropertyChangedEventArgs<T> e)
            // or static void OnPropertyChanged(AvaloniaObject sender, AvaloniaPropertyChangedEventArgs e)
            if (method.ReturnsVoid)
            {
                if (method.Parameters.Length == 1)
                {
                    var paramType = method.Parameters[0].Type.ToDisplayString();
                    return paramType.Contains("AvaloniaPropertyChangedEventArgs");
                }
                if (method.Parameters.Length == 2)
                {
                    var firstParam = method.Parameters[0].Type.ToDisplayString();
                    var secondParam = method.Parameters[1].Type.ToDisplayString();
                    return firstParam.Contains("AvaloniaObject") &&
                           secondParam.Contains("AvaloniaPropertyChangedEventArgs");
                }
            }

            return false;
        }

        private bool IsCoerceCallback(IMethodSymbol method)
        {
            // Avalonia coerce signature: T CoerceValue(AvaloniaObject sender, T value)
            if (!method.ReturnsVoid && method.Parameters.Length == 2)
            {
                var firstParam = method.Parameters[0].Type.ToDisplayString();
                return firstParam.Contains("AvaloniaObject");
            }

            return false;
        }

        private void GenerateStyledPropertyField(
            StringBuilder sb,
            string indent,
            string dpPropertyName,
            string propertyName,
            string propertyType,
            object? defaultValue,
            bool inherits,
            bool bindsTwoWayByDefault,
            string? onChanged,
            string? coerce)
        {
            var defaultBindingMode = bindsTwoWayByDefault ? "global::Avalonia.Data.BindingMode.TwoWay" : "default";

            sb.AppendLine($"{indent}    public static readonly global::Avalonia.StyledProperty<{propertyType}> {dpPropertyName} =");
            sb.Append($"{indent}        global::Avalonia.AvaloniaProperty.Register<{m_containingType.Name}, {propertyType}>(");
            sb.Append($"nameof({propertyName})");

            if (defaultValue != null)
            {
                sb.Append($", defaultValue: {FormatDefaultValue(defaultValue, propertyType)}");
            }

            if (inherits)
            {
                sb.Append(", inherits: true");
            }

            if (bindsTwoWayByDefault)
            {
                sb.Append($", defaultBindingMode: {defaultBindingMode}");
            }

            if (!string.IsNullOrEmpty(coerce))
            {
                sb.Append($", coerce: {coerce}");
            }

            sb.AppendLine(");");
            sb.AppendLine();

            // Generate property changed registration if callback exists
            if (onChanged is not null)
            {
                GeneratePropertyChangedSubscription(sb, indent, dpPropertyName, onChanged);
            }
        }

        private void GenerateDirectProperty(
            StringBuilder sb,
            string indent,
            string dpPropertyName,
            string propertyName,
            string propertyType,
            object? defaultValue,
            bool bindsTwoWayByDefault,
            string? onChanged)
        {
            var backingFieldName = $"m_{char.ToLowerInvariant(propertyName[0])}{propertyName.Substring(1)}";
            var defaultBindingMode = bindsTwoWayByDefault ? "global::Avalonia.Data.BindingMode.TwoWay" : "default";

            // Generate backing field
            sb.AppendLine($"{indent}    private {propertyType} {backingFieldName} = {FormatDefaultValue(defaultValue, propertyType)};");
            sb.AppendLine();

            sb.AppendLine($"{indent}    public static readonly global::Avalonia.DirectProperty<{m_containingType.Name}, {propertyType}> {dpPropertyName} =");
            sb.Append($"{indent}        global::Avalonia.AvaloniaProperty.RegisterDirect<{m_containingType.Name}, {propertyType}>(");
            sb.Append($"nameof({propertyName}), ");
            sb.Append($"o => o.{backingFieldName}, ");
            sb.Append($"(o, v) => o.{backingFieldName} = v");

            if (defaultValue != null)
            {
                sb.Append($", unsetValue: {FormatDefaultValue(defaultValue, propertyType)}");
            }

            if (bindsTwoWayByDefault)
            {
                sb.Append($", defaultBindingMode: {defaultBindingMode}");
            }

            sb.AppendLine(");");
            sb.AppendLine();
        }

        private void GenerateAttachedProperty(
            StringBuilder sb,
            string indent,
            string dpPropertyName,
            string propertyName,
            string propertyType,
            object? defaultValue,
            bool inherits,
            string? onChanged,
            string? coerce)
        {
            // For attached properties, we use the non-generic RegisterAttached overload
            // that doesn't require TOwner type argument (which can't be static)
            sb.AppendLine($"{indent}    public static readonly global::Avalonia.AttachedProperty<{propertyType}> {dpPropertyName} =");
            sb.Append($"{indent}        global::Avalonia.AvaloniaProperty.RegisterAttached<global::Avalonia.AvaloniaObject, {propertyType}>(");
            sb.Append($"\"{propertyName}\", typeof({m_containingType.Name})");

            if (defaultValue != null)
            {
                sb.Append($", defaultValue: {FormatDefaultValue(defaultValue, propertyType)}");
            }

            if (inherits)
            {
                sb.Append(", inherits: true");
            }

            if (!string.IsNullOrEmpty(coerce))
            {
                sb.Append($", coerce: {coerce}");
            }

            sb.AppendLine(");");
            sb.AppendLine();

            // Generate Get method
            sb.AppendLine($"{indent}    public static {propertyType} Get{propertyName}(global::Avalonia.AvaloniaObject obj)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        return obj.GetValue({dpPropertyName});");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // Generate Set method
            sb.AppendLine($"{indent}    public static void Set{propertyName}(global::Avalonia.AvaloniaObject obj, {propertyType} value)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        obj.SetValue({dpPropertyName}, value);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // Generate property changed registration if callback exists
            if (onChanged is not null)
            {
                GeneratePropertyChangedSubscription(sb, indent, dpPropertyName, onChanged);
            }
        }

        private void GeneratePropertyChangedSubscription(
            StringBuilder sb,
            string indent,
            string dpPropertyName,
            string callbackName)
        {
            sb.AppendLine($"{indent}    // Note: Subscribe to {dpPropertyName}.Changed in constructor to handle property changes");
            sb.AppendLine($"{indent}    // {dpPropertyName}.Changed.Subscribe(e => {callbackName}(e));");
            sb.AppendLine();
        }

        private string FormatDefaultValue(object? value, string propertyType)
        {
            if (value == null)
                return $"default({propertyType})!";

            if (value is string str)
                return $"\"{str}\"";
            if (value is bool b)
                return b ? "true" : "false";
            if (value is char c)
                return $"'{c}'";
            if (value is float f)
                return $"{f}f";
            if (value is double d)
                return $"{d}d";
            if (value is decimal m)
                return $"{m}m";
            if (value is long l)
                return $"{l}L";
            if (value is ulong ul)
                return $"{ul}UL";
            if (value is uint ui)
                return $"{ui}U";

            return value.ToString() ?? $"default({propertyType})!";
        }

        private T? GetAttributeValue<T>(string propertyName)
        {
            var namedArg = m_attributeData.NamedArguments
                .FirstOrDefault(kvp => kvp.Key == propertyName);

            if (namedArg.Value.Value is T typedValue)
                return typedValue;

            return default;
        }

        #endregion
    }
}
