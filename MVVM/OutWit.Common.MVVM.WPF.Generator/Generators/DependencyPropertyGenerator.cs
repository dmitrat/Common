using Microsoft.CodeAnalysis;
using System.Linq;
using System.Text;

namespace OutWit.Common.MVVM.WPF.Generator.Generators
{
    internal sealed class DependencyPropertyGenerator
    {
        #region Fields

        private readonly IPropertySymbol m_propertySymbol;
        private readonly INamedTypeSymbol m_containingType;
        private readonly AttributeData m_attributeData;
        private readonly bool m_isAttached;

        #endregion

        #region Constructors

        public DependencyPropertyGenerator(
            IPropertySymbol propertySymbol,
            INamedTypeSymbol containingType,
            AttributeData attributeData,
            bool isAttached)
        {
            m_propertySymbol = propertySymbol;
            m_containingType = containingType;
            m_attributeData = attributeData;
            m_isAttached = isAttached;
        }

        #endregion

        #region Functions

        public string Generate()
        {
            var namespaceName = m_containingType.ContainingNamespace?.ToDisplayString();
            var className = m_containingType.Name;
            var propertyName = m_propertySymbol.Name;
            var propertyType = m_propertySymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            var dpPropertyName = GetAttributeValue<string>("PropertyName") ?? $"{propertyName}Property";
            var defaultValue = GetAttributeValue<object>("DefaultValue");
            var bindsTwoWayByDefault = GetAttributeValue<bool>("BindsTwoWayByDefault");
            var affectsMeasure = GetAttributeValue<bool>("AffectsMeasure");
            var affectsArrange = GetAttributeValue<bool>("AffectsArrange");
            var affectsRender = GetAttributeValue<bool>("AffectsRender");
            var inherits = GetAttributeValue<bool>("Inherits");
            
            // Convention-based callback discovery
            var onChanged = GetAttributeValue<string>("OnChanged") ?? FindCallbackMethod($"On{propertyName}Changed");
            var coerce = GetAttributeValue<string>("Coerce") ?? FindCoerceMethod($"{propertyName}Coerce");

            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();

            if (!string.IsNullOrEmpty(namespaceName))
            {
                sb.AppendLine($"namespace {namespaceName}");
                sb.AppendLine("{");
            }

            var indent = string.IsNullOrEmpty(namespaceName) ? "" : "    ";

            sb.AppendLine($"{indent}partial class {className}");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    #region Dependency Properties");
            sb.AppendLine();

            if (m_isAttached)
            {
                GenerateAttachedProperty(sb, indent, dpPropertyName, propertyName, propertyType,
                    defaultValue, bindsTwoWayByDefault, affectsMeasure, affectsArrange, affectsRender,
                    inherits, onChanged, coerce);
            }
            else
            {
                GenerateDependencyPropertyField(sb, indent, dpPropertyName, propertyName, propertyType,
                    defaultValue, bindsTwoWayByDefault, affectsMeasure, affectsArrange, affectsRender,
                    inherits, onChanged, coerce);
            }

            sb.AppendLine($"{indent}    #endregion");
            sb.AppendLine($"{indent}}}");

            if (!string.IsNullOrEmpty(namespaceName))
            {
                sb.AppendLine("}");
            }

            return sb.ToString();
        }

        private string? FindCallbackMethod(string conventionName)
        {
            var method = m_containingType.GetMembers(conventionName)
                .OfType<IMethodSymbol>()
                .FirstOrDefault(m => IsPropertyChangedCallback(m));

            return method?.Name;
        }

        private string? FindCoerceMethod(string conventionName)
        {
            var method = m_containingType.GetMembers(conventionName)
                .OfType<IMethodSymbol>()
                .FirstOrDefault(m => IsCoerceCallback(m));

            return method?.Name;
        }

        private bool IsPropertyChangedCallback(IMethodSymbol method)
        {
            if (method.ReturnsVoid && method.Parameters.Length == 2)
            {
                var firstParam = method.Parameters[0];
                var secondParam = method.Parameters[1];

                return firstParam.Type.ToDisplayString().Contains("DependencyObject") &&
                       secondParam.Type.ToDisplayString().Contains("DependencyPropertyChangedEventArgs");
            }

            return false;
        }

        private bool IsCoerceCallback(IMethodSymbol method)
        {
            if (!method.ReturnsVoid && method.Parameters.Length == 2)
            {
                var firstParam = method.Parameters[0];
                var secondParam = method.Parameters[1];

                return firstParam.Type.ToDisplayString().Contains("DependencyObject") &&
                       secondParam.Type.SpecialType == SpecialType.System_Object;
            }

            return false;
        }

        private void GenerateDependencyPropertyField(
            StringBuilder sb,
            string indent,
            string dpPropertyName,
            string propertyName,
            string propertyType,
            object? defaultValue,
            bool bindsTwoWayByDefault,
            bool affectsMeasure,
            bool affectsArrange,
            bool affectsRender,
            bool inherits,
            string? onChanged,
            string? coerce)
        {
            sb.AppendLine($"{indent}    public static readonly global::System.Windows.DependencyProperty {dpPropertyName} =");
            sb.Append($"{indent}        global::System.Windows.DependencyProperty.Register(");
            sb.Append($"nameof({propertyName}), ");
            sb.Append($"typeof({propertyType}), ");
            sb.Append($"typeof({m_containingType.Name})");

            if (HasMetadata(defaultValue, bindsTwoWayByDefault, affectsMeasure, affectsArrange, affectsRender, inherits, onChanged, coerce))
            {
                sb.AppendLine(",");
                GenerateMetadata(sb, indent + "        ", propertyType, defaultValue, bindsTwoWayByDefault, affectsMeasure,
                    affectsArrange, affectsRender, inherits, onChanged, coerce);
            }

            sb.AppendLine(");");
            sb.AppendLine();
        }

        private void GenerateAttachedProperty(
            StringBuilder sb,
            string indent,
            string dpPropertyName,
            string propertyName,
            string propertyType,
            object? defaultValue,
            bool bindsTwoWayByDefault,
            bool affectsMeasure,
            bool affectsArrange,
            bool affectsRender,
            bool inherits,
            string? onChanged,
            string? coerce)
        {
            sb.AppendLine($"{indent}    public static readonly global::System.Windows.DependencyProperty {dpPropertyName} =");
            sb.Append($"{indent}        global::System.Windows.DependencyProperty.RegisterAttached(");
            sb.Append($"\"{propertyName}\", ");
            sb.Append($"typeof({propertyType}), ");
            sb.Append($"typeof({m_containingType.Name})");

            if (HasMetadata(defaultValue, bindsTwoWayByDefault, affectsMeasure, affectsArrange, affectsRender, inherits, onChanged, coerce))
            {
                sb.AppendLine(",");
                GenerateMetadata(sb, indent + "        ", propertyType, defaultValue, bindsTwoWayByDefault, affectsMeasure,
                    affectsArrange, affectsRender, inherits, onChanged, coerce);
            }

            sb.AppendLine(");");
            sb.AppendLine();

            sb.AppendLine($"{indent}    public static {propertyType} Get{propertyName}(global::System.Windows.DependencyObject obj)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        return ({propertyType})obj.GetValue({dpPropertyName});");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    public static void Set{propertyName}(global::System.Windows.DependencyObject obj, {propertyType} value)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        obj.SetValue({dpPropertyName}, value);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
        }

        private void GenerateMetadata(
            StringBuilder sb,
            string indent,
            string propertyType,
            object? defaultValue,
            bool bindsTwoWayByDefault,
            bool affectsMeasure,
            bool affectsArrange,
            bool affectsRender,
            bool inherits,
            string? onChanged,
            string? coerce)
        {
            var flags = BuildMetadataFlags(bindsTwoWayByDefault, affectsMeasure, affectsArrange, affectsRender, inherits);
            var hasFlags = !string.IsNullOrEmpty(flags);
            var hasCallbacks = !string.IsNullOrEmpty(onChanged) || !string.IsNullOrEmpty(coerce);

            if (hasFlags || hasCallbacks)
            {
                sb.Append($"{indent}new global::System.Windows.FrameworkPropertyMetadata(");
            }
            else
            {
                sb.Append($"{indent}new global::System.Windows.PropertyMetadata(");
            }

            sb.Append(FormatDefaultValue(defaultValue, propertyType));

            if (hasFlags)
            {
                sb.Append($", {flags}");
            }

            if (!string.IsNullOrEmpty(onChanged))
            {
                sb.Append($", {onChanged}");
            }

            if (!string.IsNullOrEmpty(coerce))
            {
                if (string.IsNullOrEmpty(onChanged))
                {
                    sb.Append(", null");
                }
                sb.Append($", {coerce}");
            }

            sb.Append(")");
        }

        private string BuildMetadataFlags(
            bool bindsTwoWayByDefault,
            bool affectsMeasure,
            bool affectsArrange,
            bool affectsRender,
            bool inherits)
        {
            var flags = new System.Collections.Generic.List<string>();

            if (bindsTwoWayByDefault)
                flags.Add("global::System.Windows.FrameworkPropertyMetadataOptions.BindsTwoWayByDefault");
            if (affectsMeasure)
                flags.Add("global::System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure");
            if (affectsArrange)
                flags.Add("global::System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange");
            if (affectsRender)
                flags.Add("global::System.Windows.FrameworkPropertyMetadataOptions.AffectsRender");
            if (inherits)
                flags.Add("global::System.Windows.FrameworkPropertyMetadataOptions.Inherits");

            return flags.Count > 0 ? string.Join(" | ", flags) : string.Empty;
        }

        private bool HasMetadata(
            object? defaultValue,
            bool bindsTwoWayByDefault,
            bool affectsMeasure,
            bool affectsArrange,
            bool affectsRender,
            bool inherits,
            string? onChanged,
            string? coerce)
        {
            return defaultValue != null ||
                   bindsTwoWayByDefault ||
                   affectsMeasure ||
                   affectsArrange ||
                   affectsRender ||
                   inherits ||
                   !string.IsNullOrEmpty(onChanged) ||
                   !string.IsNullOrEmpty(coerce);
        }

        private string FormatDefaultValue(object? value, string propertyType)
        {
            if (value == null)
                return $"default({propertyType})";

            if (value is string str)
                return $"\"{str}\"";
            if (value is bool b)
                return b ? "true" : "false";
            if (value is char c)
                return $"'{c}'";
            if (value is float f)
                return $"{f}f";
            if (value is double d)
                return $"{d}d";
            if (value is decimal m)
                return $"{m}m";
            if (value is long l)
                return $"{l}L";
            if (value is ulong ul)
                return $"{ul}UL";
            if (value is uint ui)
                return $"{ui}U";

            return value.ToString() ?? $"default({propertyType})";
        }

        private T? GetAttributeValue<T>(string propertyName)
        {
            var namedArg = m_attributeData.NamedArguments
                .FirstOrDefault(kvp => kvp.Key == propertyName);

            if (namedArg.Value.Value is T typedValue)
                return typedValue;

            return default;
        }

        #endregion
    }
}
